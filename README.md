# MySql 아키텍쳐

기본적으로 서버-클라이언트 구조이다. 데이터베이스가 서버역할 하며 데이터베이스에 연결하는 프로그램이 클라이언트이다. 서버는 크게 MySql 엔진과 스토리지 엔진으로 구분된다. 
- MySql 엔진은 요청된 sql을 분석하고 구문을 최적화하는 등 DBMS의 두뇌 역할
- 스토리지엔진은 실제 Data를 디스크 스토리지에 저장하거나 읽어오는 역할
엔진이 구별되기 때문에 엔진 간 데이터 요청 및 응답 과정이 필요함. MySql은 이러한 요청을 Handler, Handler API로 부른다.

---


### MySql 엔진

![image](https://github.com/Yuhyeingjoo/MySql-Study/assets/54518241/20c946e6-3a68-4530-a3ff-2529c8db8fea)

MySql 엔진은 Connection handler, SQL Interface, Parser, 쿼리 최적화 기능 등으로 구성된다. 스토리지 엔진은 동시에 여러 개 사용 가능하지만 MySql 엔진은 하나만 사용 가능하다.

1. Connection Pool
   아키텍쳐의 최상위 계층으로 클라이언트의 커넥션을 생성 및 관리, 요청된 쿼리를 처리한다. 또한 서버에 연결되는 클라이언트의 아이디, 패스워드 기반 인증 수행하며 해당 클라이언트가 요청한 쿼리를 실행할 권한이 있는지 확인한다. 
2. Sql Interface
   Command를 수신하고 클라이언트에게 결과를 전송하는 인터페이스. ANSI SQL을 준수한다.
3. Parser
   요청된 쿼리를 토큰으로 분리하여 트리 구조로 만든다. 파서는 문법 오류도 감지한다.
4. Optimizer
   요청된 쿼리를 다시 작성하여 높은 속도와 낮은 비용으로 처리할 수 있게 한다.
5. 캐시&버퍼
   데이터 및 인덱스에 대해 빠르게 읽고 쓰기 위해 사용되는 메모리 공간. InnoDB의 Buffer Pool과 같은 보조 저장소이다.


### 스토리지 엔진

![image](https://github.com/Yuhyeingjoo/MySql-Study/assets/54518241/a2f5f0c7-1c85-4319-a9ce-1491a2862b4b)

위 그림과 같이 스토리지 엔진을 플러그인 방식으로 사용한다.
$ show engines;
명령을 통해 사용 가능한 스토리지 엔진 목록을 확인할 수 있다. 
스토리지 엔진은 여러 개 동시에 사용 가능하다. 테이블이 사용할 스토리지 엔진을 설정하면 해당 테이블의 읽기 및 쓰기 작업은 설정된 스토리지 엔진이 처리한다. 스토리지 엔진 별로 작업 처리 방식이 다르기 때문에 성능 차이가 발생한다. 스토리지 엔진은 라이브러리를 다운하고 추가하는 방식으로 사용 및 업그레이드 가능하다. 



# Memory


![image](https://github.com/Yuhyeingjoo/DataBase-Study/assets/54518241/2155f5d8-927b-4759-9270-16094dd99c05)
MySql은 다양한 메모리 영역을 가지고 있으며 각 영역의 값을 변경하여 성능을 향상시킬 수 있다. 일반적으로 메모리는 글로벌 메모리와 로컬 메모리로 구분된다.

1.	Global Memory
   글로벌 메모리는 클라이언트 스레드 수와 무관하게 공통으로 사용되는 하나의 메모리 공간이다. 서버가 시작될 때 운영체제로부터 할당되며 관련된 설정을 변경할 경우 서버를 재시작해야 한다. 글로벌 메모리는 하기로 구성된다.
    - InnoDB Buffe Pool: 데이터를 메모리 영역에 캐싱해서 빠르게 접근하기 위한 용도로 사용된다.
    - InnoDB Change Buffer: Insert, Delete, Update 같은 데이터 변경 작업 시 사용되는 메모리 영역이다. 데이터 변경 시 인덱스도 변경 내역에 반영되는데 관련 인덱스가 많다면 자원 소모가 커진다. 이러한 이유로 인덱스에 대한 작업 성능 향상을 목적으로 하는 메모리 공간이 해당 버퍼다.
    - InnoDB Adaptive Hash index: B-Tree Index의 약점을 보완하기 위한 기능으로 자주 사용되는 컬럼을 해시로 정의하여 데이터에 접근하도록 하는 기능이다. 자주 사용하는 데이터만 해시 값으로 설정한다.
    - Query 캐시: 쿼리가 수행되면 먼저 쿼리 캐시를 서치한다. 자주 사용하는 쿼리가 있을 경우 성능이 올라간다. 그러나 테이블 구조가 변경되면 캐시에 저장된 쿼리를 재사용할 수 없으므로 자주 변경되지 않는 테이블에서 사용이 용이하다.
    - Table 캐시: 테이블을 읽고 쓰려면 테이블을 열고 닫는 과정에서 오버헤드가 크다. 그래서 테이블 캐시는 데이터베이스에서 자주 액세스되는 테이블 데이터를 메모리에 보관하는 메커니즘입니다. 메모리에 데이터를 보관함으로써 디스크 액세스와 같은 느린 입출력 작업을 피하고, 데이터를 빠르게 검색할 수 있습니다

2. Local Memory
   로컬 메모리는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 개별적인 메모리 공간이다. 클라이언트 메모리, 혹은 세션 메모리라고도 부른다. 로컬 메모리는 스레드 별로 독립적으로 할당되며 공유되지 않는다. 로컬 메모리 구성은 하기와 같다.
   - Sort Buffer: 소트 버퍼란 인덱스를 이용한 정렬이 불가능할 경우 별도의 정렬 작업을 하는데 이 때 사용되는 공간이다. SQL에서 ‘Order by’나 ‘Group by’ 키워드 사용하면 주로 해당 버퍼 쓰인다.
   - Join buffer: 조인으로 인한 새로운 테이블을 구성할 때 할당해서 사용된다.
   - Connection buffer, Result buffer: 서버는 클라이언트의 요청에 대해 스레드를 생성하는데 이때 각 스레드에는 해당 버퍼가 필요함. 네트워크 소켓을 통해 데이터를 전송하고 수신하는 데 필요한 임시 메모리 공간




# InnoDB

MySql의 기본 스토리지 엔진이며 가장 보편적으로 많이 사용된다. 


![image](https://github.com/Yuhyeingjoo/MySql-Study/assets/54518241/b97823fe-99bf-46f9-9d0d-5a2125e49773)

InnoDB 엔진 사용 시 sql 작업은 ACID 모델을 따른다. 또한 Commit, Rollback 및 복구 기능을 갖춘 트랙잭션으로 데이터를 보호한다. 

- ACID란 
- Atomicity (원자성): 트랜잭션의 모든 작업은 성공 또는 실패로 전체적으로 수행되어야 합니다. 즉, 트랜잭션 내에서 하나의 작업이라도 실패하면 전체 작업이 롤백되어야 합니다.
- Consistency (일관성): 트랜잭션의 수행 전후에 데이터베이스는 일관된 상태여야 합니다. 즉, 모든 제약 조건이 만족되어야 하며, 데이터베이스의 무결성이 유지되어야 합니다.
- Isolation (고립성): 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 다른 트랜잭션의 작업에 영향을 받지 않아야 합니다. 즉, 한 트랜잭션이 실행 중인 데이터를 다른 트랜잭션이 변경할 수 없습니다.
- Durability (지속성): 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 유지되어야 합니다. 즉, 시스템 장애가 발생하더라도 트랜잭션의 결과는 보존되어야 합니다.

InnoDB의 핵심은 Buffer Pool의 존재이다. 디스크 상의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두기 위한 공간이다. 디스크의 IO 횟수를 줄일 수 있다. Primary Key를 기반으로 쿼리를 최적화하도록 디스크에 Data를 정렬하여 저장한다. Row-Level Lock 및 MVCC를 이용하여 멀티 유저에게 접근을 제공한다. 데이터 무결성을 보장하기 위해 Foreign Key를 사용한다. 

- Foreign Key는 한 테이블의 열(속성)이 다른 테이블의 기본 키(Primary Key)나 후보 키(Candidate Key)를 참조하는 제약 조건. 기본키를 참조하여 외래 키의 데이터 무결성을 보장할 수 있고 DBMS 경우에 따라 기본키와 외래 키가 동시에 업데이트 되도록 지원할 수 있다.



### Thread

MySql은 프로세스가 아닌 스레드 기반으로 동작한다. 스레드는 2가지로 구분되는데 유저 세션에 해당하는 Foreground thread와 내부 처리 목적으로 하는 Background Thread가 여기에 해당한다. 
보통 클라이언트 커넥션 당 하나의 스레드를 사용하여 명령문을 실행한다. 그래서 많은 클라이언트가 있을수록 서버의 성능이 저하된다. 그러나 최근 MySql 에디션에서는 스레드 풀을 이용하여 성능 저하를 최소화하는 버전도 릴리즈된다.

1. Foreground Thread
   해당 스레드는 서버에 접속한 클라이언트 수만큼 존재함. 각 클라이언트는 사용자가 요청한 쿼리를 처리한다. 사용자가 작업을 마치고 세션이 종료되면 해당 스레드는 스레드 캐시로 반환된다. 캐시에 들어갈 수 있는 스레드 수는 사용자 설정에 의해 제한되며 스레드 캐시로 인해 같은 클이언트가 서버에 다시 접속했을 때의 오버헤드를 줄인다. InnoDB 에서는 메모리에 대한 읽기/쓰기 작업만 해당 스레드가 담당한다.
2. Background Thread
   InnoDB는 많은 작업을 Background Thread가 수행한다. InnoDB 엔진의 주요 백그라운드 스레드는 다음과 같다: Master Thread, Insert Buffer Thread, Log thread, Read Thread, Writ thread, Page Cleaner thread, Purge thread
      - Master thread:
         백그라운드 스레드 관리 및 다양한 태스크의 스케줄링 담당. Buffer pool의 데이터를 디스크로 비동기 Flush.
      - Insert Buffer thread: 
         Insert buffer를 Merge한다.
      - Read/Write Thread: 
         읽기/쓰기 요청을 처리한다




# SQL 처리 과정


![image](https://github.com/Yuhyeingjoo/DataBase-Study/assets/54518241/069abd03-9a3f-442f-baba-0e49670cd9e1)

- Query 캐시
먼저 쿼리를 분석하기 전 서버는 쿼리 캐시를 확인한다. 쿼리 캐시는 select 문에 대한 전체 결과 집합을 저장하고 있다. 
클라이언트가 캐시에 있는 쿼리와 동일한 것을 요청하면 바로 반환한다. 그러나 테이블이 변경되면 캐시를 사용할 수 없고 관련 캐시를 모두 삭제해야 했는데 이게 성능 저하를 유발해서 8.0 버전부터 삭제됨

- Parser
Sql 문이 문법에 맞는지 확인하고 서버에서 처리할 수 있도록 파싱 트리를 생성한다. 

- Preprocessor
파싱 단계에서 이상이 없다면 추가로 의미 분석을 진행한다. Sql 문이 해당 테이블에서 수행 가능한지 확인한다. 또한 sql 문이 수행할 권한을 가지고 있는지 확인한다. 

- Query Optimizer
해당 쿼리를 효율적으로 수행할 수 있도록 DB 내부 언어로 가공하는 단계이다. 전처리과정까지 마치면 해당 파싱 트리가 유효한 것이기 때문에 실행할 수 있지만, 최적의 옵션으로 쿼리를 수정한다
  - (참고) CBO(커스트마이즈드 버전 옵티마이저, Cost-Based Optimizer): MySql은 CBO 기반 동작하며 여기서 산출하는 비용의 기본 단위는 4bk(1페이지의 데이터를 읽는데 소비하는 비용)이다. 모든 과정은 디스크 I/O 작업을 발생시킨다는 가정 하에 비용을 계산한다. 디스크의 IO가 페이지(4kb) 단위로 이루어지니까 해당 쿼리를 실행할 때 몇 번의 IO 작업이 수행되는지에 대한 비용으로 페이지 크기가 단위. 예를 들어, 특정 실행 계획에서 디스크에서 10개의 페이지를 읽어야 한다면, 이 실행 계획의 비용은 10개의 페이지에 대한 디스크 I/O 작업 비용에 기반하여 계산된다. 

- Query Execution Engine 
쿼리 옵티마이저에서 생성된 명령대로 쿼리를 실행하며 명령에 따라 더 이상 체크할 row가 없을 때 까지 반복한다. 특히, 해당 단계에서는 실제 Data를 보관하는 스토리지 엔진과 지속적으로 Handler API Calls를 주고받는다. 

- Storage Engines
Handler API를 통해 쿼리 실행 엔진과 통신하며 쿼리 실행 엔진의 요청에 따라 데이터를 디스크에 저장하거나 읽어오는 역할을 담당한다.



# InnoDB 



![image](https://github.com/Yuhyeingjoo/DataBase-Study/assets/54518241/b59c1e36-e479-4109-9fe1-5cc37523a2a8)


## In Memory Structure


구성요소는 다음과 같다.:
1. Buffer Pool
2. Change Buffer
3. Adaptive Hash Index


---

1. Buffer Pool
   테이블 및 인덱스 데이터 캐싱을 목적으로 하는 메인 메모리 영역. 데이터 페이지, 인덱스 페이지, Undo 페이지 등 다양한 페이지가 캐싱된다. 자주 사용하는 메모리에 직접 접근하여(not 디스크 접근) 속도가 빠르며 그래서 buffer pool의 크기는 성능에 중요하다. 데이터베이스 용도로 쓰이는 서버는 버퍼 풀에 물리 메모리의 80%을 할당하기도 한다. 버퍼 풀은 페이지단위로 링크드리스트로 구성된다. 메모리에서 접근된 페이지는 리스트 앞단에 놓이며 그렇게 페이지가 쌓이다가 버퍼 풀 사이즈를 넘긴 뒷단의 리스트의 페이지는 삭제된다.
2. Change Buffer (Insert Buffer)
   Buffer Pool에 포함되는 영역으로 Secondary Index Page의 변경 내용을 캐싱하기 위한 임시 공간. Insert, Delete, Update는 많은 디스크 리소스가 필요함. Change Buffer에 임시 저장했다가 향후 다른 Read 명령에 의해 해당 페이지가 버퍼 풀에 로드될 때 병합된다. 그래서 디스크 IO를 줄일 수 있다.
3. Adaptive hash Index
   자주 사용되는 컬럼을 해시로 정의하여 B-Tree Index를 이용하지 않고 직접 데이터에 접근한다. 해시는 인덱스 키 값과 데이터 페이지 주소로 관리된다.
데이터베이스가 조회하려는 인덱스 키 값을 해시 함수에 입력으로 전달하여 해시 값을 생성한다. Adaptive Hash Index는 이 해시 값을 사용하여 해시 테이블에서 해당하는 데이터 페이지에 대한 주소(예: 페이지 번호)를 찾아서 바로 접근한다.
4. Log Buffer     
   Redo Log 파일을 기록하는 메모리 영역. InnoDB는 Log Buffer에 데이터 변경사항을 저장해둔 후에 설정된 주기 혹은 트랙잭션 커밋 시점에 디스크로 쓴다.


## On Disk Sructure

InnoDB는 모든 데이터를 디스크 상의 Tablespace라는 논리적인 공간에 저장한다. 

1. TableSpace
   데이터를 저장하는데 사용되는 가장 큰 논리적인 단위이며, 내부적으로 Segment -> Extent -> Page -> Row로 구성된다.
MySql에서 기본적으로 사용하는 것은 system Tablespace이다. Change Buffer의 저장 영역이며 테이블 및 인덱스 데이터 저장 영역.
2. Index
   MySql의 인덱스의 대부분은 B-Tree 형태다.
InnoDB 테이블에는 Clustered Index(primary Key) 라는 특별한 인덱스가 존재한다. 클러스터 인덱스는 PK값을 이용하여 Data를 정렬하여 저장합니다. EID(Key)값과 포인터가 한 쌍으로 노드에 있으며, 트리 구조를 이룬다. 포인터를 통해 해당 페이지로 바로 접근 가능하다. 기본 키를 기반으로 한 검색이나 정렬은 클러스터 인덱스를 따라 물리적인 테이블의 순서를 따라가므로, 검색 및 정렬이 매우 효율적으로 수행됩니다. 
Secondary Index
기본 키가 아닌 열의 값으로부터 기본 키를 찾게 해주는 인덱스. 열의 값과 그 레코드의 기본키를 매핑한다. 그래서 세컨더리 인덱스로 값을 검색하면 먼저 기본 키를 찾고 기본 키로부터 해당 테이블을 찾는다. 
3. Double Write Buffer
   InnoDB는 Data 손실을 방지하기 위해 DoubleWrite 라는 파일 Flush 기능을 사용한다. Buffer Pool로부터 Flush 된 page를 Data 파일에 쓰기 전에 저장하는 영역으로 디스크상에 파일로 존재한다. 

   1.	Buffer Pool의 페이지가 한 번에 flush 된다.
   2.	여러 페이지가 double write 버퍼에 write 한다. 
   3.	Double write 버퍼에 쓰인 페이지들을 순차적으로 버퍼 풀에서 디스크로 쓴다. 


- Result
쿼리 실행 후 클라이언트에게 응답하는 단계. 배열 사이즈 단위로 클라이언트에게 데이터 전달한다. 


