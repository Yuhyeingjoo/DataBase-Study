# MySql 아키텍쳐

기본적으로 서버-클라이언트 구조이다. 데이터베이스가 서버역할 하며 데이터베이스에 연결하는 프로그램이 클라이언트이다. 서버는 크게 MySql 엔진과 스토리지 엔진으로 구분된다. 
- MySql 엔진은 요청된 sql을 분석하고 구문을 최적화하는 등 DBMS의 두뇌 역할
- 스토리지엔진은 실제 Data를 디스크 스토리지에 저장하거나 읽어오는 역할
엔진이 구별되기 때문에 엔진 간 데이터 요청 및 응답 과정이 필요함. MySql은 이러한 요청을 Handler, Handler API로 부른다.

---


### MySql 엔진

![image](https://github.com/Yuhyeingjoo/MySql-Study/assets/54518241/20c946e6-3a68-4530-a3ff-2529c8db8fea)

MySql 엔진은 Connection handler, SQL Interface, Parser, 쿼리 최적화 기능 등으로 구성된다. 스토리지 엔진은 동시에 여러 개 사용 가능하지만 MySql 엔진은 하나만 사용 가능하다.

1. Connection Pool
   아키텍쳐의 최상위 계층으로 클라이언트의 커넥션을 생성 및 관리, 요청된 쿼리를 처리한다. 또한 서버에 연결되는 클라이언트의 아이디, 패스워드 기반 인증 수행하며 해당 클라이언트가 요청한 쿼리를 실행할 권한이 있는지 확인한다. 
2. Sql Interface
   Command를 수신하고 클라이언트에게 결과를 전송하는 인터페이스. ANSI SQL을 준수한다.
3. Parser
   요청된 쿼리를 토큰으로 분리하여 트리 구조로 만든다. 파서는 문법 오류도 감지한다.
4. Optimizer
   요청된 쿼리를 다시 작성하여 높은 속도와 낮은 비용으로 처리할 수 있게 한다.
5. 캐시&버퍼
   데이터 및 인덱스에 대해 빠르게 읽고 쓰기 위해 사용되는 메모리 공간. InnoDB의 Buffer Pool과 같은 보조 저장소이다.


### 스토리지 엔진

![image](https://github.com/Yuhyeingjoo/MySql-Study/assets/54518241/a2f5f0c7-1c85-4319-a9ce-1491a2862b4b)

위 그림과 같이 스토리지 엔진을 플러그인 방식으로 사용한다.
$ show engines;
명령을 통해 사용 가능한 스토리지 엔진 목록을 확인할 수 있다. 
스토리지 엔진은 여러 개 동시에 사용 가능하다. 테이블이 사용할 스토리지 엔진을 설정하면 해당 테이블의 읽기 및 쓰기 작업은 설정된 스토리지 엔진이 처리한다. 스토리지 엔진 별로 작업 처리 방식이 다르기 때문에 성능 차이가 발생한다. 스토리지 엔진은 라이브러리를 다운하고 추가하는 방식으로 사용 및 업그레이드 가능하다. 



# Memory


![image](https://github.com/Yuhyeingjoo/DataBase-Study/assets/54518241/2155f5d8-927b-4759-9270-16094dd99c05)
MySql은 다양한 메모리 영역을 가지고 있으며 각 영역의 값을 변경하여 성능을 향상시킬 수 있다. 일반적으로 메모리는 글로벌 메모리와 로컬 메모리로 구분된다.

1.	Global Memory
   글로벌 메모리는 클라이언트 스레드 수와 무관하게 공통으로 사용되는 하나의 메모리 공간이다. 서버가 시작될 때 운영체제로부터 할당되며 관련된 설정을 변경할 경우 서버를 재시작해야 한다. 글로벌 메모리는 하기로 구성된다.
    - InnoDB Buffe Pool: 데이터를 메모리 영역에 캐싱해서 빠르게 접근하기 위한 용도로 사용된다.
    - InnoDB Change Buffer: Insert, Delete, Update 같은 데이터 변경 작업 시 사용되는 메모리 영역이다. 데이터 변경 시 인덱스도 변경 내역에 반영되는데 관련 인덱스가 많다면 자원 소모가 커진다. 이러한 이유로 인덱스에 대한 작업 성능 향상을 목적으로 하는 메모리 공간이 해당 버퍼다.
    - InnoDB Adaptive Hash index: B-Tree Index의 약점을 보완하기 위한 기능으로 자주 사용되는 컬럼을 해시로 정의하여 데이터에 접근하도록 하는 기능이다. 자주 사용하는 데이터만 해시 값으로 설정한다.
    - Query 캐시: 쿼리가 수행되면 먼저 쿼리 캐시를 서치한다. 자주 사용하는 쿼리가 있을 경우 성능이 올라간다. 그러나 테이블 구조가 변경되면 캐시에 저장된 쿼리를 재사용할 수 없으므로 자주 변경되지 않는 테이블에서 사용이 용이하다.
    - Table 캐시: 테이블을 읽고 쓰려면 테이블을 열고 닫는 과정에서 오버헤드가 크다. 그래서 테이블 캐시는 데이터베이스에서 자주 액세스되는 테이블 데이터를 메모리에 보관하는 메커니즘입니다. 메모리에 데이터를 보관함으로써 디스크 액세스와 같은 느린 입출력 작업을 피하고, 데이터를 빠르게 검색할 수 있습니다

2. Local Memory
   로컬 메모리는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 개별적인 메모리 공간이다. 클라이언트 메모리, 혹은 세션 메모리라고도 부른다. 로컬 메모리는 스레드 별로 독립적으로 할당되며 공유되지 않는다. 로컬 메모리 구성은 하기와 같다.
   - Sort Buffer: 소트 버퍼란 인덱스를 이용한 정렬이 불가능할 경우 별도의 정렬 작업을 하는데 이 때 사용되는 공간이다. SQL에서 ‘Order by’나 ‘Group by’ 키워드 사용하면 주로 해당 버퍼 쓰인다.
   - Join buffer: 조인으로 인한 새로운 테이블을 구성할 때 할당해서 사용된다.
   - Connection buffer, Result buffer: 서버는 클라이언트의 요청에 대해 스레드를 생성하는데 이때 각 스레드에는 해당 버퍼가 필요함. 네트워크 소켓을 통해 데이터를 전송하고 수신하는 데 필요한 임시 메모리 공간




# InnoDB

MySql의 기본 스토리지 엔진이며 가장 보편적으로 많이 사용된다. 


![image](https://github.com/Yuhyeingjoo/MySql-Study/assets/54518241/b97823fe-99bf-46f9-9d0d-5a2125e49773)

InnoDB 엔진 사용 시 sql 작업은 ACID 모델을 따른다. 또한 Commit, Rollback 및 복구 기능을 갖춘 트랙잭션으로 데이터를 보호한다. 

- ACID란 
- Atomicity (원자성): 트랜잭션의 모든 작업은 성공 또는 실패로 전체적으로 수행되어야 합니다. 즉, 트랜잭션 내에서 하나의 작업이라도 실패하면 전체 작업이 롤백되어야 합니다.
- Consistency (일관성): 트랜잭션의 수행 전후에 데이터베이스는 일관된 상태여야 합니다. 즉, 모든 제약 조건이 만족되어야 하며, 데이터베이스의 무결성이 유지되어야 합니다.
- Isolation (고립성): 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 다른 트랜잭션의 작업에 영향을 받지 않아야 합니다. 즉, 한 트랜잭션이 실행 중인 데이터를 다른 트랜잭션이 변경할 수 없습니다.
- Durability (지속성): 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 유지되어야 합니다. 즉, 시스템 장애가 발생하더라도 트랜잭션의 결과는 보존되어야 합니다.

InnoDB의 핵심은 Buffer Pool의 존재이다. 디스크 상의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두기 위한 공간이다. 디스크의 IO 횟수를 줄일 수 있다. Primary Key를 기반으로 쿼리를 최적화하도록 디스크에 Data를 정렬하여 저장한다. Row-Level Lock 및 MVCC를 이용하여 멀티 유저에게 접근을 제공한다. 데이터 무결성을 보장하기 위해 Foreign Key를 사용한다. 

- Foreign Key는 한 테이블의 열(속성)이 다른 테이블의 기본 키(Primary Key)나 후보 키(Candidate Key)를 참조하는 제약 조건. 기본키를 참조하여 외래 키의 데이터 무결성을 보장할 수 있고 DBMS 경우에 따라 기본키와 외래 키가 동시에 업데이트 되도록 지원할 수 있다.



### Thread

MySql은 프로세스가 아닌 스레드 기반으로 동작한다. 스레드는 2가지로 구분되는데 유저 세션에 해당하는 Foreground thread와 내부 처리 목적으로 하는 Background Thread가 여기에 해당한다. 
보통 클라이언트 커넥션 당 하나의 스레드를 사용하여 명령문을 실행한다. 그래서 많은 클라이언트가 있을수록 서버의 성능이 저하된다. 그러나 최근 MySql 에디션에서는 스레드 풀을 이용하여 성능 저하를 최소화하는 버전도 릴리즈된다.

1. Foreground Thread
   해당 스레드는 서버에 접속한 클라이언트 수만큼 존재함. 각 클라이언트는 사용자가 요청한 쿼리를 처리한다. 사용자가 작업을 마치고 세션이 종료되면 해당 스레드는 스레드 캐시로 반환된다. 캐시에 들어갈 수 있는 스레드 수는 사용자 설정에 의해 제한되며 스레드 캐시로 인해 같은 클이언트가 서버에 다시 접속했을 때의 오버헤드를 줄인다. InnoDB 에서는 메모리에 대한 읽기/쓰기 작업만 해당 스레드가 담당한다.
2. Background Thread
   InnoDB는 많은 작업을 Background Thread가 수행한다. InnoDB 엔진의 주요 백그라운드 스레드는 다음과 같다: Master Thread, Insert Buffer Thread, Log thread, Read Thread, Writ thread, Page Cleaner thread, Purge thread
      - Master thread:
         백그라운드 스레드 관리 및 다양한 태스크의 스케줄링 담당. Buffer pool의 데이터를 디스크로 비동기 Flush.
      - Insert Buffer thread: 
         Insert buffer를 Merge한다.
      - Read/Write Thread: 
         읽기/쓰기 요청을 처리한다




