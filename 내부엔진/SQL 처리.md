# SQL 처리 과정


![image](https://github.com/Yuhyeingjoo/DataBase-Study/assets/54518241/069abd03-9a3f-442f-baba-0e49670cd9e1)

- Query 캐시
먼저 쿼리를 분석하기 전 서버는 쿼리 캐시를 확인한다. 쿼리 캐시는 select 문에 대한 전체 결과 집합을 저장하고 있다. 
클라이언트가 캐시에 있는 쿼리와 동일한 것을 요청하면 바로 반환한다. 그러나 테이블이 변경되면 캐시를 사용할 수 없고 관련 캐시를 모두 삭제해야 했는데 이게 성능 저하를 유발해서 8.0 버전부터 삭제됨

- Parser
Sql 문이 문법에 맞는지 확인하고 서버에서 처리할 수 있도록 파싱 트리를 생성한다. 

- Preprocessor
파싱 단계에서 이상이 없다면 추가로 의미 분석을 진행한다. Sql 문이 해당 테이블에서 수행 가능한지 확인한다. 또한 sql 문이 수행할 권한을 가지고 있는지 확인한다. 

- Query Optimizer
해당 쿼리를 효율적으로 수행할 수 있도록 DB 내부 언어로 가공하는 단계이다. 전처리과정까지 마치면 해당 파싱 트리가 유효한 것이기 때문에 실행할 수 있지만, 최적의 옵션으로 쿼리를 수정한다
  - (참고) CBO(커스트마이즈드 버전 옵티마이저, Cost-Based Optimizer): MySql은 CBO 기반 동작하며 여기서 산출하는 비용의 기본 단위는 4bk(1페이지의 데이터를 읽는데 소비하는 비용)이다. 모든 과정은 디스크 I/O 작업을 발생시킨다는 가정 하에 비용을 계산한다. 디스크의 IO가 페이지(4kb) 단위로 이루어지니까 해당 쿼리를 실행할 때 몇 번의 IO 작업이 수행되는지에 대한 비용으로 페이지 크기가 단위. 예를 들어, 특정 실행 계획에서 디스크에서 10개의 페이지를 읽어야 한다면, 이 실행 계획의 비용은 10개의 페이지에 대한 디스크 I/O 작업 비용에 기반하여 계산된다. 

- Query Execution Engine 
쿼리 옵티마이저에서 생성된 명령대로 쿼리를 실행하며 명령에 따라 더 이상 체크할 row가 없을 때 까지 반복한다. 특히, 해당 단계에서는 실제 Data를 보관하는 스토리지 엔진과 지속적으로 Handler API Calls를 주고받는다. 

- Storage Engines
Handler API를 통해 쿼리 실행 엔진과 통신하며 쿼리 실행 엔진의 요청에 따라 데이터를 디스크에 저장하거나 읽어오는 역할을 담당한다. 

- Result
쿼리 실행 후 클라이언트에게 응답하는 단계. 배열 사이즈 단위로 클라이언트에게 데이터 전달한다. 
